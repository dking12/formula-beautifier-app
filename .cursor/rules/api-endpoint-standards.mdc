---
description: Whenever we have to work on any API endpoints
globs:
alwaysApply: false
---
# API Endpoint Design Standards

## Rule Override System

### Personalized Rules

Individual engineers can create personalized rule overrides using the naming convention:
`.cursor/rules/{USER}.{RULE_NAME}.mdc`

**Examples:**

- `.cursor/rules/john.api-endpoint-standards.mdc`
- `.cursor/rules/sarah.api-endpoint-standards.mdc`

**Override Behavior:**

- Personal rules take precedence over general rules
- If a personal rule exists for a specific user, it will be used instead of the general rule
- This allows for different API design preferences while maintaining general standards

## Related Rules

### Validation and Type Safety

This rule works in conjunction with:

- **[Type-Schema Pattern Rule](type-schema-pattern.mdc)**: Enforces consistent schema and type definitions
- **[withValidation Middleware Rule](withvalidation-middleware.mdc)**: Enforces usage of validation middleware for endpoints

### Integration Points

- Use the Type-Schema Pattern for defining request/response schemas
- Apply withValidation middleware to all POST/PUT/PATCH endpoints
- Follow the established patterns for consistent API design

## Core API Design Principles

### HTTP Method Usage

Use appropriate HTTP methods for each endpoint:

- **GET**: Retrieve data (read-only operations)
- **POST**: Create new resources or perform actions
- **PUT**: Update entire resources (idempotent)
- **PATCH**: Partial updates to resources
- **DELETE**: Remove resources

### Endpoint Naming Convention

- **Use kebab-case** for all endpoint paths
- **Group by atomic functionality**, not by NextJS page structure
- **Use nouns for resources** and **verbs for actions**

## API Organization Structure

### Functional Grouping Examples

#### Email Operations

```
POST /email/send          # Send an email
GET  /email/verify        # Verify email address
POST /email/resend        # Resend verification email
```

#### User Management

```
GET    /users             # List users
POST   /users             # Create user
GET    /users/{id}        # Get specific user
PUT    /users/{id}        # Update entire user
PATCH  /users/{id}        # Partial user update
DELETE /users/{id}        # Delete user
```

#### Authentication

```
POST /auth/login          # User login
POST /auth/logout         # User logout
POST /auth/refresh        # Refresh token
POST /auth/forgot-password # Request password reset
POST /auth/reset-password # Reset password
```

#### File Operations

```
POST   /files/upload      # Upload file
GET    /files/{id}        # Download file
DELETE /files/{id}        # Delete file
GET    /files/{id}/info   # Get file metadata
```

## Implementation Guidelines

### API URL Management

- **Service-specific constants**: Create constants for each external service (e.g., `ECOMMERCE_API`, `CUSTOMER_API`)
- **Environment flexibility**: Use environment variables for each service base URL to support different environments
- **No base URL abstraction**: Each service may have different base URLs, so avoid creating a shared base URL constant
- **Version inclusion**: Include versioning in the endpoint constants, not in the service constants
- **Centralized constants**: Store all external API URLs in `src/lib/api/constants.ts`

### URL Structure Pattern

```typescript
// Service-specific constants (ends before versioning)
export const ECOMMERCE_API = process.env.ECOMMERCE_API_URL || 'https://dev-debug.bmgmoney.com/ecommerce-login-api';
export const CUSTOMER_API = process.env.CUSTOMER_API_URL || 'https://dev-debug.bmgmoney.com/customer-api';

// Endpoint constants (include full path with versioning)
export const EMAIL_ENDPOINTS = {
  SEND: `${ECOMMERCE_API}/v2.0/login/email-link`,
  VERIFY: `${ECOMMERCE_API}/v2.0/login/email-link/validate`,
} as const;

export const CUSTOMER_ENDPOINTS = {
  CONTACT_INFO: `${CUSTOMER_API}/api/v1/customer/contact-information`,
  VERIFY_PHONE: `${CUSTOMER_API}/api/v1/customer/check-phone-duplicate`,
} as const;
```

### File Structure

Organize API routes by functionality in [src/app/api/](mdc:src/app/api):

```
src/app/api/
├── auth/
│   ├── login/
│   │   └── route.ts
│   ├── logout/
│   │   └── route.ts
│   └── refresh/
│       └── route.ts
├── email/
│   ├── send/
│   │   └── route.ts
│   └── verify/
│       └── route.ts
├── users/
│   ├── route.ts          # GET /users, POST /users
│   └── [id]/
│       └── route.ts      # GET /users/{id}, PUT /users/{id}, DELETE /users/{id}
└── files/
    ├── upload/
    │   └── route.ts
    └── [id]/
        └── route.ts
```

### Response Standards

- **Consistent response format** across all endpoints
- **Appropriate HTTP status codes**
- **Error handling** with meaningful messages
- **Content-Type headers** properly set

### Example Implementation Pattern

```typescript
// src/app/api/users/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withValidation } from '@/lib/shared/utils';
import { UserSchema, UserType } from '@/lib/shared/user';

export async function GET(request: NextRequest) {
  try {
    // Implementation for GET /users
    return NextResponse.json({ users: [] }, { status: 200 });
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch users' },
      { status: 500 }
    );
  }
}

// Using withValidation middleware for POST endpoints
export const POST = withValidation<UserType>(
  { body: UserSchema },
  async (req, { name, email, age }) => {
    // Implementation for POST /users
    const user = await createUser({ name, email, age });
    return NextResponse.json({ id: user.id }, { status: 201 });
  }
);
```

**Note**: This example demonstrates integration with the [Type-Schema Pattern Rule](type-schema-pattern.mdc) and [withValidation Middleware Rule](withvalidation-middleware.mdc).

## Cross-Application Compatibility

### External Application Considerations

- **Versioning strategy** for breaking changes
- **Backward compatibility** when possible
- **Clear documentation** for external consumers
- **Rate limiting** and **authentication** for external access

### Response Format Standards

```typescript
// Success Response
{
  "success": true,
  "data": { /* response data */ },
  "message": "Operation completed successfully"
}

// Error Response
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid input provided",
    "details": { /* specific error details */ }
  }
}
```

## Checklist for API Development

### Before Creating Endpoints

- [ ] Is the HTTP method appropriate for the operation?
- [ ] Does the endpoint name follow kebab-case convention?
- [ ] Is the endpoint grouped by atomic functionality?
- [ ] Will this endpoint be used by external applications?

### During Implementation

- [ ] Are proper HTTP status codes being returned?
- [ ] Is error handling implemented consistently?
- [ ] Are response formats standardized?
- [ ] Is input validation implemented using withValidation middleware?
- [ ] Are schemas and types defined following the Type-Schema Pattern?
- [ ] Are external API URLs using service-specific constants from `src/lib/api/constants.ts`?
- [ ] Are service base URLs configurable via environment variables?

### After Implementation

- [ ] Are the endpoints documented?
- [ ] Have you tested with both internal and external consumers?
- [ ] Is the endpoint discoverable and intuitive?
- [ ] Does it follow the established patterns in the codebase?

## Migration Strategy

### From Page-Based to Function-Based

When refactoring existing endpoints:

1. **Identify atomic operations** within current endpoints
2. **Create new functional groups** for related operations
3. **Maintain backward compatibility** during transition
4. **Update documentation** and **client code** gradually
5. **Deprecate old endpoints** with proper versioning

### Example Migration

```typescript
// OLD: Page-based structure
POST /intake/contact-info
POST /intake/employment-details

// NEW: Function-based structure
POST /users/contact-info
POST /users/employment-details
// OR
POST /profile/contact-info
POST /profile/employment-details
```

Remember: API design should prioritize **usability**, **consistency**, and **maintainability** over internal application structure.
